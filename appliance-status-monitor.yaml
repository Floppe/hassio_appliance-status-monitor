blueprint:
  name: Monitor the status of an appliance - by leofabri
  description: >-
    This automation helps you to detect and control the status of an appliance
    such as a dishwasher, a washing machine, etc.


    I want this to be as universal and versatile as possible! In the blueprint, I keep referring to actions with the generic word: 'job', because the job here could be anything.


    You'll be able to tell the status of the appliance step-by-step. You can pair this with other automations and services. Maybe one that 
    sends alerts if the washing machine is not resuming a job, if you want to send TTS notifications, if 
    your fridge is somehow not turning on, and de-icing. There are so many possible use cases! All it's needed from your side is just a little bit of creativity. You could
    use the states of the State Machine and the custom actions to extend it even further.


    The State Machine:
      - <strong><u>unplugged</u></strong> - The appliance is no longer powered. 
        It happens when the user manually turns off the smart socket (from HA or the socket itself).
        
      - <strong><u>idle</u></strong> - There is no pending job, the machine is powered but idling.
        
      - <strong><u>paused</u></strong> - Indicates that a job is pending (incomplete cycle) but the appliance is not performing it. The inhibitors of these state are the <strong><i>datached_overload</i></strong> and <strong><i>unplugged</i></strong> states. 
        In this condition, the Power absorption is lower than the finishing power threshold. The appliance must be off (maybe the user turned it off manually or maybe the job needs some time to recover).
        The blueprint is waiting for the appliance to resume.

        <strong>Tip!</strong> You could also use this to diagnose and warn if a job is not resumed after x minutes. 
        
      - <strong><u>detached_overload</u></strong> - This happens when, during a cycle, the appliance used too much power and was therefore suspended. It is also technically unplugged.
        
      - <strong><u>job_ongoing</u></strong> - Triggered in two cases:
          - when a new job cycle begins: the previous one is completed and the Starting Power threshold is surpassed.
          - when a job is resumed.
          
      - <strong><u>job_completed</u></strong> - Triggered when the current incomplete job cycle is finished. The appliance consumes less than the Finishing Power threshold (also with the possibility of selecting for how long).

    <strong>First setup?</strong> <i>Check out the instructions [here](https://github.com/leofabri/hassio_appliance-status-monitor/tree/2.0.0)</i>.
  domain: automation
  input:
    appliance_socket:
      name: Smart appliance socket
      description: "The socket that is used to control this appliance."
      default: []
      selector:
        entity:
          domain: switch
    appliance_power_sensor:
      name: Power Sensor
      description: The power entity that provides the power absorption readings.
      default: []
      selector:
        entity:
          domain: sensor
    appliance_job_cycle:
      name: Appliance Job Cycle Indicator
      description:
        "A sensor that stores whether the appliance is still in a job cycle
        or not.<br>

        This has to be a boolean (so: 0 or 1).<br> <strong>off</strong> -> the appliance is
        not performing any job<br> <strong>on</strong> -> the job is incomplete.
        <br>

        <strong>Note that this entity does not provide any information about the detailed status
        of the machine (like an overload stuation). For that, you need the state machine.</strong>
        <br>      "
      default: []
      selector:
        entity:
          domain: input_boolean
    appliance_state_machine:
      name: Appliance States Sensor - State Machine
      description: >-
        The State Machine entity of this appliance. Should be something like: <i><strong>input_select.your_appliance_name_state_machine.</strong></i>
      default: []
      selector:
        entity:
          domain: input_select
    appliance_suspended_sensor:
      name: Appliance Suspended entity
      description:
        An input_number variable that turns into a value > 0. That would
        indicate that the machine was disconnected because of an overload situation.
      default: []
      selector:
        entity:
          domain: input_number
    appliance_starting_power_threshold:
      name: Starting power threshold
      description:
        Power threshold above which we assume the appliance has started
        a new job or is resuming the current one (job_ongoing state).
      default: 5
      selector:
        number:
          min: 1.0
          max: 100.0
          unit_of_measurement: W
          mode: slider
          step: 1.0
    appliance_finishing_power_threshold:
      name: Finishing power threshold
      description:
        Power threshold below which we assume the appliance has finished
        a job (job_completed state).
      default: 3
      selector:
        number:
          min: 1.0
          max: 100.0
          unit_of_measurement: W
          mode: slider
          step: 1.0
    delayed_job_completion_timer:
      name: Delayed Job Completion timer
      description: The timer that will allow to 'wait' & 'see' before assuming that a job has been completed
      default: []
      selector:
        entity:
          domain: timer
    delayed_job_completion_duration:
      name: Delayed Job Completion duration
      description: >-
        During a job cycle, some appliances may intermittently absorb less than the finishing power threshold, 
        thus entering the job_completed state (even when not finished at all).

        Despite it being a rare occurrence, it might happen. 
        With this value set, the automation will wait for x seconds and see if in that timespan the power consumption rises.

        ...

        <strong>WARNING:</strong> Setting a duration introduces a delay on the transition to the 'job_completed' state.
        Please make sure that you need this, or leave it 0 if unsure.


        <strong><i>(Suggested: 0, Default: 0 | DISABLED)</i></strong>
      default: 0.0
      selector:
        number:
          min: 0.0
          max: 900.0
          step: 1.0
          unit_of_measurement: seconds
          mode: slider

    automation_self_trigger:
      name: Automation Self-triggering entity
      description: >-
        This entity is in charge of triggering the execution of the automation when it changes from off -> on.

        Sometimes, if the power consumption of the appliance is perfectly steady, no other trigger will work, but this will.

        This variable allows the automation to call itself when some conditions are met.
      default: []
      selector:
        entity:
          domain: input_boolean

    actions_unplugged_overload:
      name: Action(s) when an overload occurs
      description: >-
        Executed when the appliance is detected as unplugged (because of an overload
        situation).

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
    actions_paused_after_overload:
      name: Action(s) when the overload situation is solved, now paused
      description: >-
        Executed when the state changes from <strong>detached_overload -> paused</strong> (NOT resuming the job).

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
    actions_paused_after_unplugged:
      name: Action(s) when the appliance is pugged back in, now paused
      description: >-
        Executed when the state changes from <strong>unplugged -> paused</strong> (NOT resuming the job).

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
    actions_resuming_after_overload:
      name: Action(s) when the overload situaton is solved, now resuming
      description: >-
        Executed when the state changes from <strong>detached_overload
        -> job_ongoing</strong> (resuming the previous job).

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:

    actions_new_job_cycle_begins:
      name: Action(s) when a new job cycle begins
      description: >-
        Executed when the appliance starts a new job cycle (<strong>idle -> job_ongoing</strong>
        state).
        Note that here the job cycle indicator is off, which means that no previous job has to be completed.

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
    actions_job_cycle_resumes:
      name: Action(s) when a job cycle resumes
      description: >-
        Executed when a pending job cycle is resumed (<strong>paused | unplugged | detached_overload -> job_ongoing</strong>
        state).
        Note that in this case, the job cycle indicator is still on. That's how I know that the appliance is resuming and not startig a job.

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
    actions_job_cycle_ends:
      name: Action(s) when a job cycle is finished
      description: >-
        Executed when the appliance finishes a job cycle (<strong>job_ongoing -> job_completed</strong>
        state).

        ...

        **WARNING:** Just use non-blocking actions in this space! No delays, actionable notifications, waits, or anything that could slow down the automation. 
        Please consider that the permanence in this state could last for a limited amount of time (seconds, potentially!). 
        This section is meant to be used to trigger other things.

        A clean solution is to call other services or use the State Machine to wake up other external automations.
      default: []
      selector:
        action:
  source_url: https://github.com/leofabri/hassio_appliance-status-monitor/blob/main/appliance-status-monitor.yaml
variables:
  appliance_socket: !input "appliance_socket"
  appliance_suspended_sensor: !input "appliance_suspended_sensor"
  delayed_job_completion_duration: !input "delayed_job_completion_duration"
  delayed_job_completion_timer: !input "delayed_job_completion_timer"
trigger:
  - platform: state
    entity_id: !input "appliance_power_sensor"
    id: power_event
  - platform: state
    entity_id: !input "appliance_socket"
    id: socket_state_change_event

  - platform: state
    entity_id: !input "appliance_state_machine"
    from: detached_overload
    to: paused
    id: paused_after_overload_event
  - platform: state
    entity_id: !input "appliance_state_machine"
    from: unplugged
    to: paused
    id: paused_after_unplugged_event
  - platform: state
    entity_id: !input "appliance_state_machine"
    from: detached_overload
    to: job_ongoing
    id: resuming_after_paused_overload_event

  - platform: state
    entity_id: !input "automation_self_trigger"
    from: "off"
    to: "on"
    id: automation_self_triggered

  - platform: event
    event_type: timer.finished
    event_data:
      entity_id: !input "delayed_job_completion_timer"
    id: job_completed_timer_finished

condition:
  - condition: or
    conditions:
      - condition: trigger
        id: power_event
      - condition: trigger
        id: socket_state_change_event

      - condition: trigger
        id: paused_after_overload_event
      - condition: trigger
        id: paused_after_unplugged_event
      - condition: trigger
        id: resuming_after_paused_overload_event

      - condition: trigger
        id: automation_self_triggered
      - condition: trigger
        id: job_completed_timer_finished
action:
  - service: input_boolean.turn_off
    data: {}
    target:
      entity_id: !input "automation_self_trigger"
  - choose:
      - conditions:
          - condition: and
            conditions:
              - condition: template
                value_template: "{{ states(appliance_suspended_sensor) | float > 0.0 }}"
              - condition: state
                entity_id: !input "appliance_job_cycle"
                state: "on"

        sequence:
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
          - service: input_select.select_option
            data:
              option: detached_overload
            target:
              entity_id: !input "appliance_state_machine"
          - choose: []
            default: !input "actions_unplugged_overload"

  - choose:
      - conditions:
          - condition: state
            entity_id: !input "appliance_job_cycle"
            state: "on"
          - condition: template
            value_template: "{{ states(appliance_suspended_sensor) | float <= 0.0 }}"
          - condition: template
            value_template: "{{ states(appliance_socket) == 'on' }}"
          - condition: numeric_state
            entity_id: !input "appliance_power_sensor"
            below: !input "appliance_finishing_power_threshold"
          - condition: or
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: unplugged
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: paused
        sequence:
          - service: input_select.select_option
            data:
              option: paused
            target:
              entity_id: !input "appliance_state_machine"

      - conditions:
          - condition: template
            value_template: "{{ states(appliance_socket) == 'off' }}"
          - condition: not
            conditions:
              - condition: template
                value_template: "{{ states(appliance_suspended_sensor) | float > 0.0 }}"
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: detached_overload
        sequence:
          - condition: not
            conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: unplugged
          - service: input_select.select_option
            data:
              option: unplugged
            target:
              entity_id: !input "appliance_state_machine"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                sequence:
                  - service: timer.cancel
                    data: {}
                    target:
                      entity_id: !input "delayed_job_completion_timer"
      - conditions:
          - condition: trigger
            id: paused_after_overload_event
        sequence:
          - choose: []
            default: !input "actions_paused_after_overload"

      - conditions:
          - condition: trigger
            id: paused_after_unplugged_event
        sequence:
          - choose: []
            default: !input "actions_paused_after_unplugged"

      - conditions:
          - condition: trigger
            id: resuming_after_paused_overload_event
        sequence:
          - choose: []
            default: !input "actions_resuming_after_overload"

    default:
      - choose:
          - conditions:
              - condition: or
                conditions:
                  - condition: state
                    entity_id: !input "appliance_job_cycle"
                    state: "off"
                  - condition: state
                    entity_id: !input "appliance_state_machine"
                    state: unplugged
                  - condition: state
                    entity_id: !input "appliance_state_machine"
                    state: paused
                  - condition: state
                    entity_id: !input "appliance_state_machine"
                    state: detached_overload
              - condition: template
                value_template: "{{ states(appliance_socket) == 'on' }}"
              - condition: numeric_state
                entity_id: !input "appliance_power_sensor"
                above: !input "appliance_starting_power_threshold"
            sequence:
              - service: input_boolean.turn_on
                data: {}
                target:
                  entity_id: !input "appliance_job_cycle"
              - service: input_select.select_option
                data:
                  option: job_ongoing
                target:
                  entity_id: !input "appliance_state_machine"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"

              - choose:
                  - conditions:
                      - condition: state
                        entity_id: !input "appliance_job_cycle"
                        state: "off"
                    sequence:
                      - choose: []
                        default: !input "actions_new_job_cycle_begins"
                default:
                  - choose: []
                    default: !input "actions_job_cycle_resumes"

          - conditions:
              - condition: state
                entity_id: !input "appliance_state_machine"
                state: job_ongoing
              - condition: state
                entity_id: !input "appliance_job_cycle"
                state: "on"
              - condition: template
                value_template: "{{ states(appliance_socket) == 'on' }}"
              - condition: numeric_state
                entity_id: !input "appliance_power_sensor"
                below: !input "appliance_finishing_power_threshold"
            sequence:
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) != 'active' }}"
                    sequence:
                      - service: timer.start
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ delayed_job_completion_duration > 0 }}"
                    sequence:
                      - choose:
                          - conditions:
                              - condition: template
                                value_template: >-
                                  {% if states(delayed_job_completion_timer) == 'active' %}
                                  {% set t_expiring_date = state_attr(delayed_job_completion_timer, 'finishes_at') %}
                                  {% set t_remaining_sec = 0 if t_expiring_date == None else (as_datetime(t_expiring_date) - now()).total_seconds() | int %}
                                  {% set t_total_duration = state_attr(delayed_job_completion_timer, 'duration') %}
                                  {% set duration_split = t_total_duration.split(':') %}
                                  {% set t_total_duration_sec  = (duration_split[0] | int * 3600) + (duration_split[1] | int * 60) + (duration_split[0] | int) %}
                                  {% set t_elapsed_sec = (t_total_duration_sec - t_remaining_sec) | int %}
                                  {{ t_elapsed_sec < (delayed_job_completion_duration) | int }}
                                  {% else %}
                                  {{0}}
                                  {% endif %}
                            sequence:
                              - service: timer.cancel
                                data: {}
                                target:
                                  entity_id: !input "delayed_job_completion_timer"
                              - service: timer.start
                                data: {}
                                target:
                                  entity_id: !input "delayed_job_completion_timer"

                              - delay:
                                  seconds: >-
                                    {{ 1 + (delayed_job_completion_duration) | int }}

                              - service: input_boolean.turn_on
                                data: {}
                                target:
                                  entity_id: !input "automation_self_trigger"

                              - condition: template
                                value_template: >-
                                  {{0}}
                default: []
              - service: input_boolean.turn_off
                data: {}
                target:
                  entity_id: !input "appliance_job_cycle"
              - service: input_select.select_option
                data:
                  option: job_completed
                target:
                  entity_id: !input "appliance_state_machine"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ states(delayed_job_completion_timer) == 'active' }}"
                    sequence:
                      - service: timer.cancel
                        data: {}
                        target:
                          entity_id: !input "delayed_job_completion_timer"
              - choose: []
                default: !input "actions_job_cycle_ends"
              - choose:
                  - conditions:
                      - condition: trigger
                        id: automation_self_triggered
                    sequence:
                      - delay:
                          minutes: 1
                      - service: input_boolean.turn_on
                        data: {}
                        target:
                          entity_id: !input "automation_self_trigger"
        default:
          choose:
            - conditions:
                - condition: state
                  entity_id: !input "appliance_job_cycle"
                  state: "off"
                - condition: not
                  conditions:
                    - condition: state
                      entity_id: !input "appliance_state_machine"
                      state: idle
              sequence:
                - service: input_select.select_option
                  data:
                    option: idle
                  target:
                    entity_id: !input "appliance_state_machine"
mode: restart
max_exceeded: silent
